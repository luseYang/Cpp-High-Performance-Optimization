# 为什么使用内存池？

1. malloc/free 的问题

`malloc` 和 `free`（或 `new/delete`）是常规的内存管理方式，但它们存在以下缺点：

- 慢：每次调用 malloc 都需要向操作系统申请内存，并维护元数据，开销较大。
- 碎片化：频繁的分配和释放导致内存碎片，降低了缓存局部性。
- 不可预测性：动态分配的时间复杂度不稳定，可能引起性能抖动。

2. 内存池的优势
更快的分配/释放：预先分配一大块内存，后续的分配只是简单的指针操作。
避免碎片化：固定大小的块减少碎片，提高缓存命中率。
可预测的性能：分配和释放的时间复杂度为 O(1)，适用于实时应用。

# 内存池的基本实现

预分配与回收

- 预先分配一大块连续的内存
- 按固定大小切分为多个小块
- 用空闲链表管理已释放的块，避免反复 malloc/free

## 单线程简单实现

```cpp
#include <iostream>

class MemoryPool {
private:
    struct Block {
        Block* next; // 指向下一个可用块
    };

    Block* freeList; // 维护空闲链表
    void* pool; // 内存池指针
    size_t blockSize, blockCount;

public:
    MemoryPool(size_t blockSize, size_t blockCount) 
        : blockSize(blockSize), blockCount(blockCount) {
        pool = std::malloc(blockSize * blockCount);
        freeList = nullptr;

        // 初始化空闲链表
        for (size_t i = 0; i < blockCount; ++i) {
            void* addr = static_cast<char*>(pool) + i * blockSize;
            free(reinterpret_cast<void*>(addr));
        }
    }

    ~MemoryPool() {
        std::free(pool);
    }

    void* allocate() {
        if (!freeList) return nullptr; // 内存池已空
        Block* block = freeList;
        freeList = freeList->next;
        return block;
    }

    void free(void* ptr) {
        Block* block = static_cast<Block*>(ptr);
        block->next = freeList;
        freeList = block;
    }
};
```
